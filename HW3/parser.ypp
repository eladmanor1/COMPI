%{
	#include <iostream>
    #include <stdlib.h>
    #include "output.hpp"
    #include"hw3.h"
//    #define YYERROR_VERBOSE 1
//#define YYDEBUG 1

    using namespace std;
    using namespace output;
	extern int yylex();
    extern int yylineno;
	int yyerror(const char * message);


	%union {
    class intType*;
    class expType*;
    class byteType*;
    class boolType*;
    class stringType*;
    };



%}

%token INT BYTE BOOL CONST TRUE FALSE IF WHILE BREAK CONTINUE STRING ASSIGN

%token ID
%token SC
%token RETURN

%nonassoc NUM
%nonassoc B

%right ASSIGN

%left OR
%left AND
%left EQUALITY
%left RELATION

%left ADD_SUB
%left MUL_DIV

%right NOT
%left LPAREN RPAREN LBRACE RBRACE
%right ELSE


%%

Program:        Statements                                          {printProductionRule(1);};
Statements:     Statement                                           {printProductionRule(2);}
                | Statements Statement                              {printProductionRule(3);};
Statement:      LBRACE Statements RBRACE                            {printProductionRule(4);}
                | Type ID SC                                        {printProductionRule(5);}
                | Type ID ASSIGN Exp SC                             {printProductionRule(6);}
                | ID ASSIGN Exp SC                                  {printProductionRule(7);}
                | Call SC                                           {printProductionRule(8);}
                | RETURN SC                                         {printProductionRule(9);}
                | IF LPAREN Exp RPAREN Statement                    {printProductionRule(10);}
                | IF LPAREN Exp RPAREN Statement ELSE Statement     {printProductionRule(11);}
                | WHILE LPAREN Exp RPAREN Statement                 {printProductionRule(12);}
                | BREAK SC                                          {printProductionRule(13);}
                | CONTINUE SC                                       {printProductionRule(14);};
Call:           ID LPAREN Exp RPAREN                                {printProductionRule(15);};
Type:           INT                                                 {printProductionRule(16);}
                | BYTE                                              {printProductionRule(17);}
                | BOOL                                              {printProductionRule(18);};
Exp:            LPAREN Exp RPAREN                                   {printProductionRule(19);}
                | Exp ADD_SUB Exp                                   {printProductionRule(20);}
                | Exp MUL_DIV Exp                                   {printProductionRule(20);}
                | ID                                                {printProductionRule(21);}
                | Call                                              {printProductionRule(22);}
                | NUM                                               {$$ = new expType($1.type, $1.value, false);}
                | NUM B                                             {$$ = new expType($1.type, $1.value, false);}
                | STRING                                            {$$ = new expType($1.type, $1.value, false);}
                | TRUE                                              {printProductionRule(26);}
                | FALSE                                             {printProductionRule(27);}
                | NOT Exp                                           {printProductionRule(28);}
                | Exp AND Exp                                       {printProductionRule(29);}
                | Exp OR Exp                                        {printProductionRule(30);}
                | Exp RELATION Exp                                   {printProductionRule(31);}
                | Exp EQUALITY Exp                                   {printProductionRule(31);}
                | LPAREN Type RPAREN Exp                            {printProductionRule(32);};



%%

int main()
{
//    yydebug = 1;
	yyparse();
}

int yyerror(const char * message)
{
    errorSyn(yylineno);
    exit(0);
}