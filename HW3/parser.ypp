%{
	#include <iostream>
    #include <stdlib.h>
    #include "hw3_output.hpp"
    #include"hw3.hpp"
//    #define YYERROR_VERBOSE 1
//#define YYDEBUG 1

    using namespace std;
    using namespace output;
	extern int yylex();
    extern int yylineno;
	int yyerror(const char * message);






%}

	%union {
    struct intType* int_type;
    struct expType* exp_type;
    struct byteType* byte_type;
    struct boolType* bool_type;
    struct stringType* string_type;
    struct typeType* type_type;
    struct callType* call_type;
    struct typeID* type_ID;
    struct statementType* statement_type;
    struct loserType* loser_type;
    }



%type <statement_type> Statement
%type <type_type> Type
%type <call_type> Call
%type <exp_type> Exp


%token <loser_type> CONST TRUE FALSE IF WHILE BREAK CONTINUE ASSIGN
%token <string_type> STRING

%token <int_type> INT
%token <byte_type> BYTE
%token <bool_type> BOOL

%token <type_ID> ID
%token <loser_type> SC
%token RETURN

%nonassoc <int_type> NUM
%nonassoc <loser_type> B

%right ASSIGN

%left OR
%left AND
%left EQUALITY
%left RELATION

%left ADD_SUB
%left MUL_DIV

%right NOT
%left LPAREN RPAREN LBRACE RBRACE
%right ELSE


%%

Program:        Statements                                          {printProductionRule(1);};
Statements:     Statement                                           {printProductionRule(2);}
                | Statements Statement                              {printProductionRule(3);};
Statement:      LBRACE Statements RBRACE                            {printProductionRule(4);}


                | Type ID SC                                        {if(checkSymbolTableForSymbol($2->name)){
                                                                    printf("ERRR\n");
                                                                    exit(0);
                                                                    }
                                                                    addSymbolTableRow($2->name, $2->type);
                                                                    $$ = new statementType($1->name);}


                | Type ID ASSIGN Exp SC                             {if(checkSymbolTableForSymbol($2->name)){
                                                                    printf("ERRR\n");
                                                                    exit(0);
                                                                    }
                                                                    if(!compareType($1->name, $4->name)){
                                                                    }
                                                                    addSymbolTableRow($2->name, $2->type);
                                                                    $$ = new statementType($1->name);}


                | ID ASSIGN Exp SC                                  {printProductionRule(7);}
                | Call SC                                           {printProductionRule(8);}
                | RETURN SC                                         {printProductionRule(9);}
                | IF LPAREN Exp RPAREN Statement                    {printProductionRule(10);}
                | IF LPAREN Exp RPAREN Statement ELSE Statement     {printProductionRule(11);}
                | WHILE LPAREN Exp RPAREN Statement                 {printProductionRule(12);}
                | BREAK SC                                          {printProductionRule(13);}
                | CONTINUE SC                                       {printProductionRule(14);};


Call:           ID LPAREN Exp RPAREN                                {callType* callobj = creatCallObj($1->name,$3);
                                                                     if(callobj == nullptr){
                                                                        printf("error in call object");
                                                                     }
                                                                     else{
                                                                        $$ = callobj;
                                                                     }
                                                                     };


Type:           INT                                                 {printProductionRule(16);}
                | BYTE                                              {printProductionRule(17);}
                | BOOL                                              {printProductionRule(18);};
Exp:            LPAREN Exp RPAREN                                   {printProductionRule(19);}
                | Exp ADD_SUB Exp                                   {printProductionRule(20);}
                | Exp MUL_DIV Exp                                   {printProductionRule(20);}
                | ID                                                {$$ = new expType($1->type, $1->value, true, $1->name);}
                | Call                                              {$$ = new expType($1->type,unionTypes((int*)nullptr),false, $1->name);}
                | NUM                                               {$$ = new expType($1->type, unionTypes($1->value), false, "");}
                | NUM B                                             {printf("meow\n");}
                | STRING                                            {$$ = new expType($1->type, unionTypes(new string($1->value)), false, "");}
                | TRUE                                              {printProductionRule(26);}
                | FALSE                                             {printProductionRule(27);}
                | NOT Exp                                           {printProductionRule(28);}
                | Exp AND Exp                                       {printProductionRule(29);}
                | Exp OR Exp                                        {printProductionRule(30);}
                | Exp RELATION Exp                                   {printProductionRule(31);}
                | Exp EQUALITY Exp                                   {printProductionRule(31);}
                | LPAREN Type RPAREN Exp                            {printProductionRule(32);};



%%

int main()
{
//    yydebug = 1;
	yyparse();
}

int yyerror(const char * message)
{
    errorSyn(yylineno);
    exit(0);
}