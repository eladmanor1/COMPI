%{
	#include <iostream>
    #include <stdlib.h>
    #include "hw3_output.hpp"
    #include"hw3.hpp"
//    #define YYERROR_VERBOSE 1
//#define YYDEBUG 1

    using namespace std;
    using namespace output;
	extern int yylex();
    extern int yylineno;
	int yyerror(const char * message);

	extern vector<symbolTable> symbolTablesStack;
    extern stack<int> offsetStack;


%}

	%union {
    struct intType* int_type;
    struct expType* exp_type;
    struct byteType* byte_type;
    struct boolType* bool_type;
    struct stringType* string_type;
    struct typeType* type_type;
    struct callType* call_type;
    struct typeID* type_ID;
    struct statementType* statement_type;
    struct loserType* loser_type;
    }


%type <statement_type> Statement
%type <type_type> Type
%type <call_type> Call
%type <exp_type> Exp


%token <loser_type> CONST TRUE FALSE IF WHILE BREAK CONTINUE ASSIGN
%token <string_type> STRING

%token <int_type> INT
%token <byte_type> BYTE
%token <bool_type> BOOL

%token <type_ID> ID
%token <loser_type> SC
%token RETURN

%nonassoc <int_type> NUM
%nonassoc <loser_type> B

%right ASSIGN

%left OR
%left AND
%left EQUALITY
%left RELATION

%left ADD_SUB
%left MUL_DIV

%right NOT
%left LPAREN RPAREN LBRACE RBRACE
%right ELSE


%%

Program:        Statements                                          {printProductionRule(1);};
Statements:     Statement                                           {printProductionRule(2);}
                | Statements Statement                              {printProductionRule(3);};
Statement:      LBRACE Statements RBRACE                            {printProductionRule(4);}


                | Type ID SC                                        {printf("Statement -> Type ID SC\n");
                                                                    if(checkSymbolTableForSymbol($2->name)){
                                                                        errorDef(yylineno, $2->name);
                                                                        exit(0);
                                                                    }
                                                                    addSymbolTableRow($2->name, $1->name);
                                                                    $$ = new statementType($1->name);}


                | Type ID ASSIGN Exp SC                             {if(checkSymbolTableForSymbol($2->name)){
                                                                        errorDef(yylineno, $2->name);
                                                                        exit(0);
                                                                    }
                                                                    if(!compareType($1->name, $4->type)){
                                                                        errorMismatch(yylineno);
                                                                        exit(0);
                                                                    }
                                                                    addSymbolTableRow($2->name, $1->name);
                                                                    $$ = new statementType($1->name);
                                                                    }
                | ID ASSIGN Exp SC                                  {if(!checkSymbolTableForSymbol($1->name)){
                                                                        errorUndef(yylineno, $1->name);
                                                                        exit(0);}
                                                                    if(compareType(getSymbolType($1->name), $3->type)) {
                                                                        //change value
                                                                        $$ = new statementType($1->name);
                                                                    }
                                                                    else if(getSymbolType($1->name) == "int" && $3->type == "byte"){
                                                                        //cast and then change value
                                                                        $$ = new statementType($1->name);
                                                                    }
                                                                    else{
                                                                        errorMismatch(yylineno);
                                                                        exit(0);
                                                                    }
                                                                    }


                | Call SC                                           {printProductionRule(8);}
                | RETURN SC                                         {printProductionRule(9);}
                | IF LPAREN Exp RPAREN Statement                    {printProductionRule(10);}
                | IF LPAREN Exp RPAREN Statement ELSE Statement     {printProductionRule(11);}
                | WHILE LPAREN Exp RPAREN Statement                 {printProductionRule(12);}
                | BREAK SC                                          {printProductionRule(13);}
                | CONTINUE SC                                       {printProductionRule(14);};


Call:           ID LPAREN Exp RPAREN                                {callType* callobj = creatCallObj($1->name, $3->type);
                                                                     if(callobj == nullptr){
                                                                        errorUndefFunc(lineno, $1->name);
                                                                        exit(0);
                                                                     }
                                                                     else{
                                                                        $$ = callobj;
                                                                     }
                                                                     };


Type:           INT                                                 {$$ = new typeType("int");}
                | BYTE                                              {$$ = new typeType("byte");}
                | BOOL                                              {$$ = new typeType("bool");};
Exp:            LPAREN Exp RPAREN                                   {printProductionRule(19);}
                | Exp ADD_SUB Exp                                   {printProductionRule(20);}
                | Exp MUL_DIV Exp                                   {printProductionRule(20);}
                | ID                                                {if(!checkSymbolTableForSymbol($1->name)){
                                                                    errorUndef(yylineno, $1->name);
                                                                    }
                                                                    $$ = new expType(getSymbolType($1->name), $1->value, true, $1->name);
                                                                    }

                | Call                                              {$$ = new expType($1->type, unionTypes((int*)nullptr), false, $1->name);}
                | NUM                                               {$$ = new expType($1->type, unionTypes($1->value), false, "");}
                | NUM B                                             {$$ = new expType("byte", unionTypes((byte)$1->value), false, "");}
                | STRING                                            {$$ = new expType($1->type, unionTypes(new string($1->value)), false, "");}
                | TRUE                                              {$$ = new expType("bool", unionTypes(true), false, "");}
                | FALSE                                             {$$ = new expType("bool", unionTypes(false), false, "");}
                | NOT Exp                                           {if(!compareType("bool", $2->type)){
                                                                        errorMismatch(yylineno);
                                                                        exit(0);
                                                                    }
                                                                    $$ = new expType("bool", unionTypes(!($2->value.boolValue)), false, "");}
                | Exp AND Exp                                       {if(compareType($1->type, $3->type) && $1->type == "bool"){
                                                                        $$ = new expType("bool", unionTypes(($1->value.boolValue && $3->value.boolValue)), false, "");
                                                                    }
                                                                    else{
                                                                        errorMismatch(yylineno);
                                                                        exit(0);}
                                                                    }
                | Exp OR Exp                                        {if(compareType($1->type, $3->type) && $1->type == "bool"){
                                                                        $$ = new expType("bool", unionTypes(($1->value.boolValue || $3->value.boolValue)), false, "");
                                                                    }
                                                                    else{
                                                                        errorMismatch(yylineno);
                                                                        exit(0);}
                                                                    }
                | Exp RELATION Exp                                  {if (($1->type == "byte" || $1->type == "int") && ($3->type == "byte" || $3->type == "int")){
                                                                        // I am lying here. I am doing OR, when I should be doing RELATION... lier lier pants on fire
                                                                        $$ = new expType("bool", unionTypes(($1->value.boolValue || $3->value.boolValue)), false, "");
                                                                    }
                                                                    else{
                                                                        errorMismatch(yylineno);
                                                                        exit(0);
                                                                    }
                                                                    }
                | Exp EQUALITY Exp                                  {if (($1->type == "byte" || $1->type == "int") && ($3->type == "byte" || $3->type == "int")){
                                                                    // I am lying here. I am doing OR, when I should be doing RELATION... lier lier pants on fire
                                                                    $$ = new expType("bool", unionTypes(($1->value.boolValue || $3->value.boolValue)), false, "");
                                                                    }
                                                                    else{
                                                                        errorMismatch(yylineno);
                                                                        exit(0);
                                                                    }
                                                                    }
                | LPAREN Type RPAREN Exp                            {printProductionRule(32);};



%%

int main()
{
//    yydebug = 1;
	yyparse();
}

int yyerror(const char * message)
{
    errorSyn(yylineno);
    exit(0);
}