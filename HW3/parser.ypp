%{
	#include <iostream>
    #include <stdlib.h>
    #include "hw3_output.hpp"
    #include"hw3.hpp"
//    #define YYERROR_VERBOSE 1
//#define YYDEBUG 1

    using namespace std;
    using namespace output;
	extern int yylex();
    extern int yylineno;
	int yyerror(const char * message);


	%union {
    struct intType* int_type;
    struct expType* exp_type;
    struct byteType* byte_type;
    struct boolType* bool_type;
    struct stringType* string_type;
    struct typeType* type_type;
    struct callType* call_type;
    struct typeID* type_ID;
    } myUnion;

    #define YYSTYPE myUnion



%}

%token CONST TRUE FALSE IF WHILE BREAK CONTINUE STRING ASSIGN

%token <int_type> INT
%token <byte_type> BYTE
%token <bool_type> BOOL

%token <type_ID> ID
%token SC
%token RETURN

%nonassoc NUM
%nonassoc B

%right ASSIGN

%left OR
%left AND
%left EQUALITY
%left RELATION

%left ADD_SUB
%left MUL_DIV

%right NOT
%left LPAREN RPAREN LBRACE RBRACE
%right ELSE


%%

Program:        Statements                                          {printProductionRule(1);};
Statements:     Statement                                           {printProductionRule(2);}
                | Statements Statement                              {printProductionRule(3);};
Statement:      LBRACE Statements RBRACE                            {printProductionRule(4);}


                | Type ID SC                                        {if(checkSymbolTableForSymbol($2.name)){
                                                                    printf("ERRR\n");
                                                                    exit(0);
                                                                    }
                                                                    addSymbolTableRow($2.name, $2.type);
                                                                    $$ = new statementType($1.name);}


                | Type ID ASSIGN Exp SC                             {if(checkSymbolTableForSymbol($2.name)){
                                                                    printf("ERRR\n");
                                                                    exit(0);
                                                                    }
                                                                    if(!compareType($1.name, $4.name)){
                                                                        if(
                                                                    }
                                                                    addSymbolTableRow($2.name, $2.type);
                                                                    $$ = new statementType($1.name);}


                | ID ASSIGN Exp SC                                  {printProductionRule(7);}
                | Call SC                                           {printProductionRule(8);}
                | RETURN SC                                         {printProductionRule(9);}
                | IF LPAREN Exp RPAREN Statement                    {printProductionRule(10);}
                | IF LPAREN Exp RPAREN Statement ELSE Statement     {printProductionRule(11);}
                | WHILE LPAREN Exp RPAREN Statement                 {printProductionRule(12);}
                | BREAK SC                                          {printProductionRule(13);}
                | CONTINUE SC                                       {printProductionRule(14);};


Call:           ID LPAREN Exp RPAREN                                {callType* callobj = creatCallObj($1.name,$3);
                                                                     if(callobj == nullptr){ print("error in call object" }
                                                                     $$ = callobj}


Type:           INT                                                 {printProductionRule(16);}
                | BYTE                                              {printProductionRule(17);}
                | BOOL                                              {printProductionRule(18);};
Exp:            LPAREN Exp RPAREN                                   {printProductionRule(19);}
                | Exp ADD_SUB Exp                                   {printProductionRule(20);}
                | Exp MUL_DIV Exp                                   {printProductionRule(20);}
                | ID                                                {$$ = new expType($1.type, $1.value, true, $1.name);}
                | Call                                              {$$ = new expType($1.type,nullptr,false}
                | NUM                                               {$$ = new expType($1.type, $1.value, false);}
                | NUM B                                             {$$ = new expType($1.type, $1.value, false);}
                | STRING                                            {$$ = new expType($1.type, $1.value, false);}
                | TRUE                                              {printProductionRule(26);}
                | FALSE                                             {printProductionRule(27);}
                | NOT Exp                                           {printProductionRule(28);}
                | Exp AND Exp                                       {printProductionRule(29);}
                | Exp OR Exp                                        {printProductionRule(30);}
                | Exp RELATION Exp                                   {printProductionRule(31);}
                | Exp EQUALITY Exp                                   {printProductionRule(31);}
                | LPAREN Type RPAREN Exp                            {printProductionRule(32);};



%%

int main()
{
//    yydebug = 1;
	yyparse();
}

int yyerror(const char * message)
{
    errorSyn(yylineno);
    exit(0);
}